# IntroToProgrammingFMI-practicalClasses

Homeworks for functional programming


Task second term test


1. Характеризирайте накратко структурата от данни "опашка"

Опашката е крайна редица от елементи от един и същ тип.
Операцията включване на елемент е допустима само за единия
(например десния) край на редицата, който се нарича край на
опашката. Операцията изключване на елемент е допустима
само за другия (левия) край на редицата, който се нарича начало
на опашката. Възможен е пряк достъп само до елемента,
намиращ се в началото на опашката.
При описаната организация на логическите операции,
последният включен в опашката елемент се изключва последен, а
първият – първи. Затова опашката се определя още като структура
от данни „пръв влязъл – пръв излязъл“ (first in – first out, FIFO).

2. Опишете накратко стратегията за търсене на път в граф в дълбочина (depth-first search).

При търсенето в дълбочина фронтът се обработва като стек.
• Ако фронтът е [p1,p2, ... ], то:
	o избира се p1;
	o ацикличните пътища p1', p1", … , p1(k), които продължават
		(разширяват) p1, се добавят в началото на стека (преди p2),
		т.е. фронтът придобива вида [p1', p1'', … , p1(k), p2, ... ];
	o p2 се обработва едва след като се изследват всички пътища,
		които са продължения на p1.
		
		
3. Обяснете понятието „алгебричен тип“ в езика Haskell. Дайте два примера за дефиниции на
различни видове алгебрични типове.

Дефиницията на един алгебричен тип започва с ключовата
дума data, след която се записват името на типа, знак за
равенство и конструкторите на типа. Името на типа и имената
на конструкторите задължително започват с главни букви.

Пример 1:
data Colour = Blue | Green | Yellow | Red
Пример 2:
data Figure = Circle Float| Rectangle Float Float| Ellipse Float Float


4. Дайте пример за дефиниция на алгебричен тип като производен екземпляр на множество
класове. Обяснете накратко значението на тази дефиниция.

data Colour = Blue | Green | Yellow | Red
deriving (Eq,Ord,Enum,Show,Read)
data Figure = Circle Float| Rectangle Float Float| Ellipse Float Float
deriving (Eq,Show,Read)

Възможно е да се дефинира нов алгебричен тип като например
Colour или Figure, който да бъде екземпляр на множество
вградени класове.


5. Обяснете понятието „полиморфна функция“. Дайте пример за полиморфна функция в езика
Haskell.

Една полиморфна функция, например length (намиране на
дължина на списък, чийто елементи могат да бъдат от произволен
тип), има единствена дефиниция, която работи върху всички нейни
типове. 


6. Как се дефинират класове в Haskell? Дайте пример за дефиниция на клас.

За да може да се дефинира един клас, е необходимо да се
избере (зададе) неговото име и да се опишат ограниченията, които
трябва да удовлетворява даден тип a, за да принадлежи на този
клас.
Типовете, които принадлежат на даден клас, се наричат
екземпляри на този клас.
Най-важно (определящо) за класа Eq е наличието на
функцията == от тип a -> a -> Bool, която проверява дали два
елемента на даден тип a, който е екземпляр на Eq, са равни:
class Eq a where
 (==) :: a -> a -> Bool
 
 
7. Обяснете същността на „мързеливото“ оценяване (lazy evaluation) в езика Haskell. Дайте
поне два примера, които илюстрират различни аспекти на „мързеливото“ оценяване.

Мързеливото“ оценяване (lazy evaluation) е стратегия на
оценяване, която по стандарт стои в основата на работата на
всички интерпретатори на Haskell. Същността на тази стратегия е,
че интерпретаторът оценява даден аргумент на дадена функция
само ако (и доколкото) стойността на този аргумент е необходима
за пресмятането на целия резултат. Нещо повече, ако даден
аргумент е съставен (например е вектор или списък), то се
оценяват само тези негови компоненти, чиито стойности са
необходими от гледна точка на получаването на резултата. При
това дублиращите се подизрази се оценяват по не повече от един
път.


8. Нека функцията f е дефинирана както следва:
f [] ys = ys
f (x:xs) ys = x:(f xs ys)
Докажете с помощта на принципа на структурната индукция, че за всеки краен списък ys e
вярно
f ys [] = ys .

f (y:ys) [] = y:(f ys []) = y:y1:(f (tail ys) []) ... = y:y1:...yk:[] (k = 1 .. length ys) => ys
